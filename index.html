<!DOCTYPE html>
<!-- ═══════════════════════════════════════════════════════════════════════════
     KDTS — MODELO DE MANUTENÇÃO: TAXA DE CUSTO c(D, T, K)
     Implementación web del modelo delay-time con degradación natural (mezcla
     Weibull) y choques externos (Poisson/Exponencial). 9 escenarios de falla.
     ═══════════════════════════════════════════════════════════════════════════ -->
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Modelo de manutenção K&Delta;TS</title>

  <!--
    FONTES GOOGLE (3 famílias):
    · JetBrains Mono  → usada en inputs numéricos, valores calculados y código
    · Barlow Condensed → usada en títulos, sidebar y botones
    · Barlow           → usada en el texto corrido del body
  -->
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Barlow+Condensed:wght@300;600;800&family=Barlow:wght@400;500&display=swap" rel="stylesheet">

<style>
  /* ══════════════════════════════════════════════════════════════════════════
     VARIABLES CSS GLOBALES — paleta de colores y tokens de diseño
     Cambiar cualquier valor aquí afecta TODA la página inmediatamente.
     ══════════════════════════════════════════════════════════════════════════ */
  :root {
    --bg:           #0a0c10;  /* fondo negro de toda la página (body) */
    --panel:        #111318;  /* fondo de los paneles de parámetros y cards */
    --border:       #1e2330;  /* color de todos los bordes y líneas divisorias */
    --accent:       #f0a500;  /* dorado: etiquetas de parámetros, badges, botón primario */
    --accent2:      #00d4aa;  /* teal: títulos de grupo, valor del resultado, modales */
    --accent3:      #e05260;  /* rojo: botón X de cierre al hacer hover */
    --text:         #c8cdd8;  /* color del texto principal */
    --text-dim:     #5a6070;  /* texto secundario atenuado, subtítulos */
    --code-bg:      #0d1117;  /* fondo de los inputs numéricos */
    --hint-bg:      #1a1f0d;  /* fondo del formula-box (recuadro de parámetros usados) */
    --hint-border:  #3a5020;  /* borde del formula-box */
  }

  /* Reset global: elimina márgenes y paddings por defecto de todos los elementos */
  * { margin: 0; padding: 0; box-sizing: border-box; }

  /* BODY — fondo oscuro, fuente base Barlow, oculta scroll horizontal */
  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Barlow', sans-serif;
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* ── HEADER ──
     Barra superior fija de 64px. Se queda pegada al tope al hacer scroll
     (position:sticky). Fondo semitransparente con blur para ver el contenido detrás. */
  header {
    border-bottom: 1px solid var(--border);
    padding: 0 40px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    height: 64px;           /* altura fija del header — modifica aquí para hacerlo más alto */
    position: sticky;
    top: 0;
    z-index: 100;           /* encima de todo el contenido al hacer scroll */
    background: rgba(10,12,16,0.95);
    backdrop-filter: blur(10px);
  }

  /* Logo "KDTS·" en la esquina izquierda del header */
  .logo {
    font-family: 'Barlow Condensed', sans-serif;
    font-weight: 800;
    font-size: 20px;        /* tamaño del texto KDTS */
    letter-spacing: 2px;
    color: #fff;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  /* El punto "·" dentro de .logo está en un <span> — este selector lo colorea en dorado */
  .logo span { color: var(--accent); }

  /* Área derecha del header — contiene la pastilla "MODELO DE MANUTENÇÃO" */
  .header-right {
    display: flex;
    align-items: center;
    gap: 8px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: var(--text-dim);
    letter-spacing: 1px;
  }

  /* Pastilla con borde teal en la esquina superior derecha */
  .header-tag {
    padding: 4px 10px;
    border: 1px solid var(--border);
    border-radius: 2px;
    color: var(--accent2);
    border-color: var(--accent2);
  }

  /* ── LAYOUT — Grid de 2 columnas: sidebar fijo + área de contenido ──
     Cambiar "280px" ancha o estrecha el sidebar izquierdo.
     El "1fr" hace que el área de contenido ocupe el resto del espacio disponible. */
  .container {
    display: grid;
    grid-template-columns: 280px 1fr;  /* ← ancho del sidebar | contenido */
    min-height: calc(100vh - 64px);    /* altura total menos el header */
  }

  /* ── SIDEBAR ──
     Panel lateral izquierdo fijo en pantalla. Tiene su propio scroll vertical
     si el contenido supera la altura de la ventana. */
  aside {
    border-right: 1px solid var(--border);
    padding: 24px 0;
    position: sticky;
    top: 64px;                        /* empieza justo debajo del header */
    height: calc(100vh - 64px);       /* ocupa toda la pantalla menos el header */
    overflow-y: auto;                  /* scroll propio si hay demasiados ítems */
  }

  /* Título de categoría dentro del sidebar (ej: "DISTRIBUIÇÕES", "CUSTOS") */
  .sidebar-section {
    padding: 8px 24px 4px;
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 10px;
    letter-spacing: 3px;
    font-weight: 600;
    color: #fff;
    margin-top: 16px;
  }

  /* Cada ítem clickeable del sidebar — el borde izquierdo transparente
     se pone activo (colorido) cuando JS agrega la clase .active */
  .sidebar-item {
    padding: 10px 24px;
    cursor: pointer;
    border-left: 3px solid transparent;  /* ← se colorea con .active en JS */
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .sidebar-item:hover { background: rgba(255,255,255,0.03); cursor: pointer; }

  /* Recuadro con la letra inicial del ítem (W, E, C, P, R) en dorado */
  .sidebar-num {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    width: 22px; height: 22px;
    border-radius: 3px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    background: rgba(240,165,0,0.15);
    color: var(--accent);
  }

  /* Texto de la etiqueta del ítem del sidebar */
  .sidebar-label {
    font-size: 13px;
    line-height: 1.3;
    color: var(--text);
  }

  /* ── MAIN — área de contenido principal a la derecha del sidebar ── */
  main {
    padding: 40px 50px;   /* espaciado interno — reducir si se quiere más ancho útil */
    max-width: 900px;     /* ancho máximo del contenido */
  }

  /* ── SECTION LABEL ──
     Separador de sección con texto en mayúsculas y línea horizontal a la derecha.
     La línea se genera con ::after usando flex:1 y height:1px.
     Aparece encima de cada bloque de parámetros (Weibull, Exponencial, Custos, etc.) */
  .section-label {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 11px;
    letter-spacing: 3px;
    font-weight: 600;
    color: #fff;
    margin-bottom: 12px;
    margin-top: 28px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  /* Línea horizontal que completa el separador de sección */
  .section-label::after {
    content: '';
    flex: 1;
    height: 1px;
    background: var(--border);
  }

  /* ── EXERCISE HEADER ── Bloque de título grande al inicio del contenido principal
     Contiene el número "KDTS" (72px) y el bloque de título + subtítulo */
  .ex-header {
    display: flex;
    align-items: flex-start;
    gap: 20px;
    margin-bottom: 32px;
  }
  /* El texto grande "KDTS" (72px, blanco, Barlow Condensed 800) a la izquierda del título */
  .ex-number-big {
    font-family: 'Barlow Condensed', sans-serif;
    font-weight: 800;
    font-size: 72px;      /* ← cambiar para agrandar/achicar el número decorativo */
    line-height: 1;
    opacity: 0.3;
    color: #fff;
    flex-shrink: 0;
  }
  /* Contenedor del título, subtítulo y pastilla de nivel */
  .ex-title-block { flex: 1; }
  /* Pastilla "POLÍTICA DE MANUTENÇÃO" en dorado sobre fondo semitransparente */
  .level-tag {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    letter-spacing: 2px;
    padding: 3px 8px;
    border-radius: 2px;
    display: inline-block;
    margin-bottom: 8px;
    background: rgba(240,165,0,0.15);
    color: var(--accent);
  }
  /* Título principal del ejercicio (36px, blanco, Barlow Condensed) */
  .ex-title {
    font-family: 'Barlow Condensed', sans-serif;
    font-weight: 800;
    font-size: 36px;      /* ← cambiar el tamaño del título aquí */
    color: #fff;
    line-height: 1.1;
  }
  /* Subtítulo en JetBrains Mono atenuado debajo del título */
  .ex-subtitle {
    color: var(--text-dim);
    font-size: 13px;
    margin-top: 6px;
    font-family: 'JetBrains Mono', monospace;
  }

  /* ── PARAM PANEL ──
     Contenedor de cada bloque de parámetros (Weibull, Delay-time, Costos, Política).
     Fondo oscuro con borde y esquinas redondeadas. */
  .param-panel {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 20px 24px;
    margin-bottom: 0;
  }

  /* Grupo de parámetros relacionados dentro de un panel (ej: "COMPONENTE FRACO") */
  .param-group {
    margin-bottom: 22px;    /* espacio entre grupos — el último grupo no tiene margen */
  }
  .param-group:last-child { margin-bottom: 0; }

  /* Título de grupo en teal con línea inferior (ej: "COMPONENTE FRACO", "DELAY-TIME") */
  .group-label {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 10px;
    letter-spacing: 3px;
    font-weight: 600;
    color: var(--accent2);  /* color teal — cambiar aquí para alterar títulos de grupo */
    margin-bottom: 12px;
    padding-bottom: 6px;
    border-bottom: 1px solid var(--border);
  }

  /* Fila de un parámetro: [etiqueta dorada] [descripción blanca] [input numérico] */
  .param-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 10px;
    gap: 12px;
  }
  /* Etiqueta del parámetro en dorado (ej: n₁, b₁, λ, cᶠ, D, T, K) */
  .param-row label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 15px;
    color: var(--accent);   /* dorado — cambiar para alterar el color de las etiquetas */
    min-width: 36px;
    flex-shrink: 0;
  }
  /* Texto descriptivo del parámetro */
  .param-row .desc {
    font-size: 14px;
    color: #fff;
    flex: 1;
    line-height: 1.3;
  }
  /* Campo de entrada numérico — 86px de ancho, fondo oscuro, texto monoespaciado */
  .param-row input[type="number"] {
    width: 86px;            /* ← cambiar para hacer los inputs más anchos/angostos */
    background: var(--code-bg);
    border: 1px solid var(--border);
    border-radius: 3px;
    color: var(--text);
    font-family: 'JetBrains Mono', monospace;
    font-size: 15px;
    padding: 5px 9px;
    text-align: right;
    transition: border-color 0.2s;
    flex-shrink: 0;
  }
  /* Al enfocar el input: resalta el borde en dorado con sombra sutil */
  .param-row input[type="number"]:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 2px rgba(240,165,0,0.1);
  }

  /* ── CONCEPTS ── Etiquetas de concepto (chips) en el bloque de descripción del modelo
     (ej: "9 escenarios", "Weibull mezcla", "Delay-time") */
  .concepts {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 12px;
  }
  /* Estilo de cada chip de concepto */
  .concept-tag {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    padding: 4px 10px;
    background: rgba(255,255,255,0.04);
    border: 1px solid var(--border);
    border-radius: 3px;
    color: #fff;
  }

  /* ── ACTIONS ── Contenedor de los botones CALCULAR y RESETAR
     Tiene una línea divisoria superior (border-top) y margen superior */
  .actions {
    display: flex;
    gap: 12px;
    margin-top: 32px;
    padding-top: 24px;
    border-top: 1px solid var(--border);
    align-items: center;
  }

  /* Estilos base compartidos por todos los botones */
  .btn {
    font-family: 'Barlow Condensed', sans-serif;
    font-weight: 600;
    font-size: 15px;
    letter-spacing: 1px;
    padding: 10px 22px;
    border-radius: 4px;
    cursor: pointer;
    border: none;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  /* Botón primario dorado "CALCULAR TAXA DE CUSTO"
     Al hacer hover sube 1px. Al estar desactivado (durante el cálculo) se pone gris. */
  .btn-primary {
    background: var(--accent);  /* dorado — cambiar para alterar el color del botón */
    color: #000;
  }
  .btn-primary:hover { background: #ffc225; transform: translateY(-1px); }
  .btn-primary:active { transform: translateY(0); }
  .btn-primary:disabled { background: var(--text-dim); cursor: not-allowed; transform: none; }

  /* Botón secundario "RESETAR" — transparente con borde gris */
  .btn-secondary {
    background: transparent;
    color: var(--text);
    border: 1px solid var(--border);
  }
  .btn-secondary:hover { border-color: var(--text); }

  /* ── SPINNER ── Rueda giratoria que reemplaza el ícono ▶ del botón durante el cálculo.
     JS inyecta <span class="spinner"> en lugar de <span id="btnIcon"> */
  @keyframes spin { to { transform: rotate(360deg); } }
  .spinner {
    width: 14px; height: 14px;
    border: 2px solid rgba(0,0,0,0.3);
    border-top-color: #000;
    border-radius: 50%;
    animation: spin 0.7s linear infinite;  /* velocidad de giro — cambiar 0.7s */
    display: inline-block;
  }

  /* ── PROGRESS ── Barra de progreso animada que aparece en #outputArea mientras calcula.
     JS controla el ancho de .progress-fill (0% → 90% → 100%). */
  .progress-wrap {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 18px 20px;
  }
  /* Fila superior: texto "Calculando..." a la izquierda, porcentaje a la derecha */
  .progress-top {
    display: flex;
    justify-content: space-between;
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    color: var(--text-dim);
    margin-bottom: 10px;
  }
  .progress-top span:last-child { color: var(--accent2); }  /* porcentaje en teal */
  /* Pista gris de 4px de alto que contiene el relleno animado */
  .progress-track {
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    overflow: hidden;
  }
  /* Relleno animado — gradiente de teal a dorado, con brillo (box-shadow).
     JS ajusta el style.width para avanzar la barra. */
  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--accent2), var(--accent));
    border-radius: 2px;
    transition: width 0.3s ease;
    width: 0%;
    box-shadow: 0 0 8px var(--accent2);
  }

  /* ── RESULTS ── Contenedor de los resultados post-cálculo (cards + tabla + formula-box)
     Generado dinámicamente por JS en showOutput() dentro de runModel() */
  .results-wrap {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  /* Grid de 2 cards de resumen: "Variáveis de decisão" y "Taxa de custo" */
  .summary-cards {
    display: grid;
    grid-template-columns: 1fr 1fr;  /* ← cambiar a "1fr" para una sola columna */
    gap: 12px;
  }
  /* Cada card individual */
  .card {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 16px 18px;
  }
  /* Título del card (ej: "TAXA DE CUSTO") */
  .card-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: #fff;
    letter-spacing: 1px;
    text-transform: uppercase;
    margin-bottom: 6px;
  }
  /* Valor principal del card — número grande en teal (ej: el valor c calculado) */
  .card-value {
    font-family: 'JetBrains Mono', monospace;
    font-size: 24px;          /* ← cambiar para agrandar/achicar el número resultado */
    font-weight: 700;
    color: var(--accent2);
  }
  /* Texto auxiliar debajo del valor */
  .card-sub {
    font-size: 11px;
    color: #fff;
    margin-top: 3px;
  }

  /* ── TABLE ── Tabla de resultados generada dinámicamente por JS en runModel()
     Muestra columnas K | D | T | Taxa de custo c(D,T,K) */
  .results-table {
    width: 100%;
    border-collapse: collapse;
    font-family: 'JetBrains Mono', monospace;
    font-size: 13px;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 6px;
    overflow: hidden;
  }
  /* Cabecera de la tabla — fondo más oscuro (#161b22) */
  .results-table th {
    text-align: left;
    padding: 10px 18px;
    font-size: 10px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: #fff;
    background: #161b22;    /* ← cambiar el color de fondo del header de la tabla */
    border-bottom: 1px solid var(--border);
  }
  /* Celdas del cuerpo de la tabla */
  .results-table td {
    padding: 10px 18px;
    border-bottom: 1px solid rgba(30,35,48,0.6);
    transition: background 0.15s;
  }
  .results-table tr:last-child td { border-bottom: none; }
  .results-table tr:hover td { background: rgba(255,255,255,0.02); }
  /* Columna K/D/T: texto blanco */
  .results-table .k-col  { color: #fff; }
  /* Columna de la tasa de costo: texto atenuado en negrita */
  .results-table .c-col  { color: var(--text); font-weight: 700; }
  /* Fila marcada como "mejor resultado" — fondo teal muy tenue */
  .results-table tr.best td { background: rgba(0,212,170,0.06); }
  /* En la fila "best", el valor de la tasa aparece en teal */
  .results-table tr.best .c-col { color: var(--accent2); }

  /* Badge "CALCULADO" dentro de la celda de la tasa de costo */
  .best-badge {
    font-size: 9px;
    background: rgba(0,212,170,0.2);
    color: var(--accent2);
    padding: 2px 7px;
    border-radius: 2px;
    margin-left: 8px;
    letter-spacing: 1px;
    font-weight: 400;
  }

  /* ── FORMULA BOX ── Recuadro verde oscuro con borde izquierdo teal.
     Aparece debajo de la tabla de resultado mostrando los parámetros utilizados. */
  .formula-box {
    background: var(--hint-bg);
    border: 1px solid var(--hint-border);
    border-left: 3px solid var(--accent2);  /* borde izquierdo teal de 3px */
    border-radius: 4px;
    padding: 14px 18px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    color: #8aa860;       /* color verde claro del texto de parámetros */
    line-height: 1.8;
  }
  /* Título "PARÁMETROS UTILIZADOS" dentro del formula-box */
  .formula-box .formula-title {
    font-size: 10px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--accent2);
    margin-bottom: 8px;
    font-family: 'Barlow Condensed', sans-serif;
    font-weight: 600;
    letter-spacing: 3px;
  }

  /* ── ERROR ── Recuadro rojo que aparece cuando hay error de validación o de cálculo.
     JS lo inyecta en #outputArea con showOutput('<div class="error-box">...') */
  .error-box {
    background: rgba(224,82,96,0.1);
    border: 1px solid rgba(224,82,96,0.3);
    border-radius: 6px;
    padding: 14px 18px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    color: #ff8080;
  }

  /* ── PLACEHOLDER ── Estado inicial del área de resultado (#outputArea).
     Muestra un ícono SVG de documento y el texto "Configure los parámetros...".
     Se reemplaza por JS al calcular o al resetear. */
  .placeholder {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 60px 20px;
    gap: 14px;
    color: #fff;
  }
  .placeholder svg { opacity: 0.25; }  /* ícono semitransparente */
  .placeholder p {
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    letter-spacing: 1px;
    text-align: center;
  }

  /* ── TOAST ── Notificación flotante en la esquina inferior derecha.
     Invisible por defecto (opacity:0, translateY(80px)).
     JS agrega la clase .show para hacerla aparecer. Se oculta sola a los 3s. */
  .toast {
    position: fixed;
    bottom: 30px;
    right: 30px;
    background: var(--panel);
    border: 1px solid var(--border);
    border-left: 3px solid var(--accent2);
    border-radius: 6px;
    padding: 12px 20px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    color: var(--accent2);
    transform: translateY(80px);   /* fuera de pantalla hacia abajo por defecto */
    opacity: 0;
    transition: all 0.3s;
    z-index: 999;
  }
  /* Estado visible: desliza hacia arriba y aparece */
  .toast.show { transform: translateY(0); opacity: 1; }

  /* ── SCROLLBAR ── Personalización de la barra de scroll (solo Chrome/Edge) */
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

  /* ── RESPONSIVE ── En pantallas menores a 768px:
     el grid pasa a 1 columna, el sidebar se oculta, márgenes reducidos */
  @media (max-width: 768px) {
    .container { grid-template-columns: 1fr; }
    aside { display: none; }
    main { padding: 24px 20px; }
    header { padding: 0 20px; }
  }

  /* ── MODAL DE FÓRMULAS ──
     Overlay oscuro semitransparente con blur que cubre toda la pantalla.
     Por defecto invisible (opacity:0, pointer-events:none).
     JS agrega la clase .open para hacerlo visible al hacer clic en el sidebar. */
  .modal-overlay {
    position: fixed;
    inset: 0;                        /* cubre toda la pantalla */
    background: rgba(0,0,0,0.75);
    backdrop-filter: blur(4px);
    z-index: 200;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    pointer-events: none;            /* invisible no recibe clics */
    transition: opacity 0.25s;
  }
  /* Clase que JS agrega/quita para mostrar/ocultar el modal */
  .modal-overlay.open { opacity: 1; pointer-events: all; }
  /* Recuadro blanco del modal — 660px de ancho, desplazado 16px hacia abajo por defecto */
  .modal {
    background: var(--panel);
    border: 1px solid var(--border);
    border-top: 3px solid var(--accent2);  /* borde superior teal */
    border-radius: 8px;
    width: 660px;           /* ← cambiar el ancho del modal */
    max-width: 92vw;
    max-height: 85vh;
    overflow-y: auto;
    transform: translateY(16px);    /* desplazado para la animación de entrada */
    transition: transform 0.25s;
  }
  /* Al abrirse, el modal sube a su posición natural */
  .modal-overlay.open .modal { transform: translateY(0); }
  /* Cabecera del modal: ícono + título + botón de cierre */
  .modal-header {
    padding: 18px 24px 14px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .modal-header-left { display: flex; align-items: center; gap: 12px; }
  /* Cuadro de ícono (letra inicial) en la cabecera del modal */
  .modal-icon {
    width: 30px; height: 30px;
    border-radius: 4px;
    background: rgba(0,212,170,0.15);
    color: var(--accent2);
    font-family: 'JetBrains Mono', monospace;
    font-size: 13px; font-weight: 700;
    display: flex; align-items: center; justify-content: center;
  }
  /* Título principal del modal */
  .modal-title {
    font-family: 'Barlow Condensed', sans-serif;
    font-weight: 800; font-size: 20px; color: #fff;
  }
  /* Subtítulo en gris atenuado debajo del título */
  .modal-subtitle {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px; color: var(--text-dim);
    margin-top: 2px; letter-spacing: 1px;
  }
  /* Botón X de cierre — se pone rojo al hacer hover */
  .modal-close {
    background: transparent;
    border: 1px solid var(--border);
    color: var(--text-dim);
    width: 28px; height: 28px;
    border-radius: 4px; cursor: pointer;
    font-size: 14px; transition: all 0.15s;
    display: flex; align-items: center; justify-content: center;
  }
  .modal-close:hover { border-color: var(--accent3); color: var(--accent3); }
  /* Área de contenido del modal (fórmulas) */
  .modal-body { padding: 20px 24px; display: flex; flex-direction: column; gap: 16px; }
  /* Tarjeta individual de fórmula dentro del modal */
  .formula-card {
    background: var(--code-bg);
    border: 1px solid var(--border);
    border-radius: 6px; overflow: hidden;
  }
  /* Cabecera de la tarjeta de fórmula (ej: "COMPONENTE FRACO — f₁(x)") */
  .formula-card-header {
    padding: 10px 16px;
    background: #161b22;
    border-bottom: 1px solid var(--border);
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 11px; letter-spacing: 2px;
    font-weight: 600; color: var(--accent);
    text-transform: uppercase;
  }
  /* Cuerpo de la tarjeta: centrado, con mínimo 60px de alto para el LaTeX renderizado */
  .formula-card-body {
    padding: 20px; text-align: center; overflow-x: auto;
    min-height: 60px; display: flex; align-items: center; justify-content: center;
  }
  /* Descripción textual debajo de la fórmula */
  .formula-card-desc {
    padding: 12px 16px 14px;
    font-size: 12.5px; color: var(--text-dim);
    line-height: 1.6;
    border-top: 1px solid var(--border);
  }
  /* Estilo del <code> inline dentro de las descripciones */
  .formula-card-desc code {
    font-family: 'JetBrains Mono', monospace;
    background: rgba(255,255,255,0.06);
    padding: 1px 5px; border-radius: 3px;
    font-size: 11px; color: var(--accent2);
  }
  /* Símbolo ∑ al final de cada ítem del sidebar — aparece al hacer hover */
  .sidebar-item .hint-dot {
    margin-left: auto;
    font-size: 9px;
    color: var(--accent2);
    opacity: 0.5;
    font-family: 'JetBrains Mono', monospace;
    transition: opacity 0.2s;
  }
  .sidebar-item:hover .hint-dot { opacity: 1; }
</style>

<script>
  /*
   * MATHJAX — Configuración del renderizador de fórmulas matemáticas LaTeX.
   * Se configura ANTES de cargar el script de MathJax (línea siguiente).
   *
   * · inlineMath:   usa $...$ para fórmulas inline (dentro del texto)
   * · displayMath:  usa $$...$$ para fórmulas en bloque (centradas)
   * · typeset:false → NO renderiza automáticamente al cargar la página.
   *                   MathJax solo se activa cuando JS llama a
   *                   MathJax.typesetPromise([overlay]) dentro de openModal().
   */
  window.MathJax = {
    tex: { inlineMath: [['$','$']], displayMath: [['$$','$$']] },
    svg: { fontCache: 'global' },
    startup: { typeset: false }
  };
</script>
<!-- Librería MathJax 3.2.2 desde CDN — renderiza los $$...$$ dentro de los modales -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-svg.min.js"></script>
</head>
<!-- ═══════════════════════════════════════════════════════════════════════════
     ESTRUCTURA HTML DE LA PÁGINA
     ═══════════════════════════════════════════════════════════════════════════ -->
<body>

<!-- ── HEADER: barra superior fija con logo y etiqueta ── -->
<header>
  <!-- Logo: "KDTS" blanco + "·" dorado (el <span> recibe color var(--accent) por CSS) -->
  <div class="logo">K&Delta;TS</div>
  <div class="header-right">
    <!-- Pastilla con borde teal en la esquina derecha del header -->
    <span class="header-tag">MODELO DE MANUTENÇÃO</span>
  </div>
</header>

<!-- ── CONTAINER: grid de 2 columnas [sidebar 280px | contenido 1fr] ── -->
<div class="container">

  <!-- ── SIDEBAR: panel lateral izquierdo con ítems de navegación ──
       Cada .sidebar-item abre un modal con openModal('id').
       El símbolo ∑ (.hint-dot) aparece al hacer hover sobre el ítem. -->
  <aside>
    <!-- Categoría 1: Distribuciones de probabilidad -->
    <div class="sidebar-section">DISTRIBUIÇÕES</div>
    <!-- Ítem W → abre modal con fórmulas de la mezcla Weibull (f₁, f₂, fx) -->
    <div class="sidebar-item" onclick="openModal('modal-weibull')">
      <div class="sidebar-num">W</div>
      <div class="sidebar-label">Mezcla Weibull</div>
      <span class="hint-dot">∑</span>
    </div>
    <!-- Ítem E → abre modal con fórmulas de delay-time y choques (fh, Rh, fz, Rz) -->
    <div class="sidebar-item" onclick="openModal('modal-exp')">
      <div class="sidebar-num">E</div>
      <div class="sidebar-label">Delay-time y Choques</div>
      <span class="hint-dot">∑</span>
    </div>

    <!-- Categoría 2: Parámetros de costo -->
    <div class="sidebar-section">CUSTOS</div>
    <!-- Ítem C → abre modal con definición de cf, cp, ci, cn, cc -->
    <div class="sidebar-item" onclick="openModal('modal-custos')">
      <div class="sidebar-num">C</div>
      <div class="sidebar-label">Parámetros de costo</div>
      <span class="hint-dot">∑</span>
    </div>

    <!-- Categoría 3: Variables de decisión -->
    <div class="sidebar-section">POLÍTICA</div>
    <!-- Ítem P → abre modal con fórmulas de la política (c(D,T,K), restricción K·D≤T) -->
    <div class="sidebar-item" onclick="openModal('modal-politica')">
      <div class="sidebar-num">P</div>
      <div class="sidebar-label">K&Delta;TS</div>
      <span class="hint-dot">∑</span>
    </div>

    <!-- Categoría 4: Resultado del cálculo -->
    <div class="sidebar-section">RESULTADO</div>
    <!-- Ítem R → abre modal con la fórmula completa de la tasa de costo -->
    <div class="sidebar-item" onclick="openModal('modal-taxa')">
      <div class="sidebar-num">R</div>
      <div class="sidebar-label">Tasa de costo</div>
      <span class="hint-dot">∑</span>
    </div>
  </aside>

  <!-- ── MAIN: área de contenido principal (derecha del sidebar) ── -->
  <main>

    <!-- ── BLOQUE DE TÍTULO PRINCIPAL ──
         Dos columnas flex: número decorativo "KDTS" (72px) + bloque de título -->
    <div class="ex-header">
      <!-- Número decorativo grande — cambiar el texto aquí para modificarlo en pantalla -->
      <div class="ex-number-big">K&Delta;TS</div>
      <div class="ex-title-block">
        <!-- Pastilla de tipo: "POLÍTICA DE MANUTENÇÃO" en dorado -->
        <span class="level-tag">POLÍTICA DE MANUTENÇÃO</span>
        <!-- Título principal del modelo -->
        <div class="ex-title">Con costo de degradación natural y choques</div>
        <!-- Subtítulo descriptivo en JetBrains Mono -->
        <div class="ex-subtitle">mezcla Weibull · exponencial · delay-time · 9 escenarios</div>
      </div>
    </div>

    <!-- ── DESCRIPCIÓN DEL MODELO ──
         Panel con texto explicativo, la fórmula central c(D,T,K) y chips de concepto -->
    <div class="param-panel" style="line-height:1.7; font-size:14.5px;">
      Modelo basado en la teoría de delay-time: un defecto surge en el instante <strong style="color:var(--accent)">x</strong> (degradación) o <strong style="color:var(--accent)">z</strong> (choque), pero solo causa falla tras un período de delay-time <strong style="color:var(--accent)">h</strong>. La tasa de costo se calcula como:
      <!-- Recuadro verde con la fórmula central del modelo -->
      <div class="formula-box" style="margin-top:14px;">
        <div class="formula-title">Fórmula central</div>
        C(K, &Delta;, T) = E[Costo del ciclo] / E[Duración del ciclo] = SC / SV
      </div>
      <!-- Chips de concepto — agregar/quitar <span class="concept-tag"> para más chips -->
      <div class="concepts" style="margin-top:14px;">
        <span class="concept-tag">9 escenarios</span>
        <span class="concept-tag">Weibull mezcla</span>
        <span class="concept-tag">Exponencial choque</span>
        <span class="concept-tag">Delay-time</span>
        <span class="concept-tag">Integração numérica</span>
      </div>
    </div>

    <!-- ── SECCIÓN: DEGRADAÇÃO NATURAL — MISTURA WEIBULL ──
         Parámetros de la distribución de mezcla Weibull para la vida útil del componente.
         id="sec-weibull" es el destino del scroll desde el sidebar (scrollTo) -->
    <div class="section-label" id="sec-weibull">DEGRADAÇÃO NATURAL — MISTURA WEIBULL</div>
    <div class="param-panel">
      <!-- Grupo 1: Parámetros del componente débil (fracción 'a' de la población) -->
      <div class="param-group">
        <div class="group-label">COMPONENTE FRACO</div>
        <div class="param-row">
          <label>n₁</label>
          <span class="desc">Escala de la Weibull (componente débil)</span>
          <!-- id="n1" → leído por getParams() → usado como η₁ en f_debil(x) en JS -->
          <input type="number" id="n1" value="0.3" step="0.1" min="0.01">
        </div>
        <div class="param-row">
          <label>b₁</label>
          <span class="desc">Forma de la Weibull (componente débil)</span>
          <!-- id="b1" → leído por getParams() → usado como β₁ en f_debil(x) en JS -->
          <input type="number" id="b1" value="3" step="0.5" min="0.1">
        </div>
      </div>
      <!-- Grupo 2: Parámetros del componente fuerte (fracción '1-a' de la población) -->
      <div class="param-group">
        <div class="group-label">COMPONENTE FORTE</div>
        <div class="param-row">
          <label>n₂</label>
          <span class="desc">Escala de la Weibull (componente fuerte)</span>
          <!-- id="n2" → leído por getParams() → usado como η₂ en f_forte(x) en JS -->
          <input type="number" id="n2" value="3" step="0.1" min="0.01">
        </div>
        <div class="param-row">
          <label>b₂</label>
          <span class="desc">Forma de la Weibull (componente fuerte)</span>
          <!-- id="b2" → leído por getParams() → usado como β₂ en f_forte(x) en JS -->
          <input type="number" id="b2" value="3" step="0.5" min="0.1">
        </div>
      </div>
      <!-- Grupo 3: Proporción de la mezcla -->
      <div class="param-group" style="margin-bottom:0">
        <div class="group-label">MISTURA</div>
        <div class="param-row">
          <label>a</label>
          <span class="desc">Proporción de componentes débiles (0 &lt; a &lt; 1)</span>
          <!-- id="a" → leído por getParams() → peso de la mezcla: fx = a·f_debil + (1-a)·f_forte -->
          <input type="number" id="a" value="0.05" step="0.01" min="0" max="1">
        </div>
      </div>
    </div>

    <!-- ── SECCIÓN: DELAY-TIME E CHOQUES — EXPONENCIAL ──
         Parámetros de las distribuciones exponenciales del período P-F y de los choques.
         id="sec-exp" → destino del scroll desde el sidebar -->
    <div class="section-label" id="sec-exp">DELAY-TIME E CHOQUES — EXPONENCIAL</div>
    <div class="param-panel">
      <!-- Grupo: parámetros del delay-time (período entre detección y falla) -->
      <div class="param-group">
        <div class="group-label">DELAY-TIME</div>
        <div class="param-row">
          <label>λ</label>
          <span class="desc">Tasa exponencial del delay-time (inverso de la media)</span>
          <!-- id="l" → leído por getParams() → tasa λ de fh(h) = λ·e^(-λh) y Rh(h) = e^(-λh) -->
          <input type="number" id="l" value="1" step="0.1" min="0.01">
        </div>
      </div>
      <!-- Grupo: parámetros de los choques externos (proceso de Poisson) -->
      <div class="param-group" style="margin-bottom:0">
        <div class="group-label">CHOQUES EXTERNOS</div>
        <div class="param-row">
          <label>μ</label>
          <span class="desc">Tasa de llegada de los choques externos</span>
          <!-- id="u" → leído por getParams() → tasa μ de fz(z) = μ·e^(-μz) y Rz(z) = e^(-μz) -->
          <input type="number" id="u" value="0.5" step="0.1" min="0.01">
        </div>
      </div>
    </div>

    <!-- ── SECCIÓN: PARÂMETROS DE CUSTO ──
         Los 5 costos del modelo. id="sec-custos" → destino del scroll -->
    <div class="section-label" id="sec-custos">PARÁMETROS DE COSTO</div>
    <div class="param-panel">
      <div class="param-group" style="margin-bottom:0">
        <div class="group-label">CUSTOS DE SUBSTITUIÇÃO E INSPEÇÃO</div>
        <div class="param-row">
          <label>cᶠ</label>
          <span class="desc">Costo de sustitución correctiva (falla)</span>
          <!-- id="cf" → costo cuando el componente falla (escenarios 1, 3, 5, 7) -->
          <input type="number" id="cf" value="5" step="0.5" min="0">
        </div>
        <div class="param-row">
          <label>cₚ</label>
          <span class="desc">Costo de sustitución preventiva</span>
          <!-- id="cp" → costo cuando el defecto es detectado (escenarios 2, 4, 6, 8, 9) -->
          <input type="number" id="cp" value="1" step="0.1" min="0">
        </div>
        <div class="param-row">
          <label>cᵢ</label>
          <span class="desc">Costo por inspección realizada</span>
          <!-- id="ci" → multiplicado por el número de inspecciones realizadas -->
          <input type="number" id="ci" value="0.1" step="0.05" min="0">
        </div>
        <div class="param-row">
          <label>cₙ</label>
          <span class="desc">Costo unitario de degradación natural</span>
          <!-- id="cn" → penalización por tiempo en estado defectuoso (degradación natural) -->
          <input type="number" id="cn" value="0.04" step="0.01" min="0">
        </div>
        <div class="param-row">
          <label>cᶜ</label>
          <span class="desc">Costo unitario de choque externo</span>
          <!-- id="cc" → penalización por tiempo en estado defectuoso (choque externo) -->
          <input type="number" id="cc" value="0.04" step="0.01" min="0">
        </div>
      </div>
    </div>

    <!-- ── SECCIÓN: POLÍTICA DE MANUTENÇÃO ──
         Variables de decisión D, T, K. id="sec-politica" → destino del scroll.
         Restricción estructural del modelo: K·D ≤ T (validada en runModel()) -->
    <div class="section-label" id="sec-politica">POLÍTICA DE MANUTENÇÃO</div>
    <div class="param-panel">
      <div class="param-group" style="margin-bottom:0">
        <div class="group-label">VARIÁVEIS DE DECISÃO</div>
        <div class="param-row">
          <label>D</label>
          <span class="desc">Intervalo entre inspecciones periódicas</span>
          <!-- id="D" → intervalo entre inspecciones. Define los subintervalos [(i-1)D, iD) -->
          <input type="number" id="D" value="0.9092" step="0.01" min="0.01">
        </div>
        <div class="param-row">
          <label>T</label>
          <span class="desc">Edad de sustitución preventiva</span>
          <!-- id="T" → edad de sustitución preventiva por tiempo. Define el fin del ciclo -->
          <input type="number" id="T" value="8" step="0.5" min="0.1">
        </div>
        <div class="param-row">
          <label>K</label>
          <span class="desc">Número de inspecciones en el ciclo</span>
          <!-- id="K" → número de inspecciones. Debe cumplir K·D ≤ T (validado en runModel()) -->
          <input type="number" id="K" value="5" step="1" min="0" style="width:86px;">
        </div>
        <!-- Recordatorio visual de la restricción estructural del modelo -->
        <div style="margin-top:8px; font-family:'JetBrains Mono',monospace; font-size:11px; color:#fff; padding: 6px 0;">
          Restrição: K·&Delta; ≤ T
        </div>
      </div>
    </div>

    <!-- ── BOTONES DE ACCIÓN ──
         btnRun: dispara runModel() → valida parámetros → calcula → muestra resultado
         btnIcon: ícono ▶ que JS reemplaza por spinner (.spinner) al calcular
         btnText: texto que JS cambia entre "CALCULAR..." y "CALCULANDO..."
         btn-secondary: llama a resetForm() → restaura todos los campos a valores por defecto -->
    <div class="actions">
      <button class="btn btn-primary" id="btnRun" onclick="runModel()">
        <span id="btnIcon">▶</span>
        <span id="btnText">CALCULAR TAXA DE CUSTO</span>
      </button>
      <button class="btn btn-secondary" onclick="resetForm()">RESETAR</button>
    </div>

    <!-- ── SECCIÓN: RESULTADO ──
         id="sec-resultado" → destino del scroll desde el sidebar.
         #outputArea es el contenedor DINÁMICO: JS reemplaza su innerHTML con:
           · Placeholder inicial (ícono SVG + texto)
           · .progress-wrap (barra de progreso durante el cálculo)
           · .results-wrap (cards + tabla + formula-box al terminar)
           · .error-box (si hay error de validación o cálculo) -->
    <div class="section-label" id="sec-resultado">RESULTADO — TASA DE COSTO C(K, &Delta;, T)</div>
    <div id="outputArea">
      <!-- Estado inicial: ícono decorativo SVG de documento + mensaje instructivo.
           Este contenido es reemplazado por JS en showOutput() al calcular o resetear. -->
      <div class="placeholder">
        <svg width="48" height="48" viewBox="0 0 48 48" fill="none">
          <rect x="8" y="8" width="32" height="32" rx="3" stroke="#5a6070" stroke-width="1.5"/>
          <line x1="16" y1="20" x2="32" y2="20" stroke="#5a6070" stroke-width="1.5"/>
          <line x1="16" y1="26" x2="28" y2="26" stroke="#5a6070" stroke-width="1.5"/>
          <line x1="16" y1="32" x2="24" y2="32" stroke="#5a6070" stroke-width="1.5"/>
        </svg>
        <p>Configure los parámetros arriba<br>y haga clic en CALCULAR</p>
      </div>
    </div>

  </main>
</div>

<!-- ── TOAST: notificación flotante en esquina inferior derecha ──
     JS escribe el texto con showToast(msg) y agrega la clase .show para hacerlo visible.
     Se oculta automáticamente a los 3 segundos. -->
<div class="toast" id="toast"></div>

<!-- ── MODAL: MISTURA WEIBULL ── -->
<div class="modal-overlay" id="modal-weibull" onclick="closeModalOut(event, 'modal-weibull')">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-header-left">
        <div class="modal-icon">W</div>
        <div>
          <div class="modal-title">Mistura Weibull</div>
          <div class="modal-subtitle">DEGRADAÇÃO NATURAL</div>
        </div>
      </div>
      <button class="modal-close" onclick="closeModal('modal-weibull')">✕</button>
    </div>
    <div class="modal-body">

      <div class="formula-card">
        <div class="formula-card-header">Componente Fraco — f₁(x)</div>
        <div class="formula-card-body">
          $$f_1(x) = \frac{\beta_1}{\eta_1}\left(\frac{x}{\eta_1}\right)^{\beta_1-1} \exp\!\left[-\left(\frac{x}{\eta_1}\right)^{\beta_1}\right]$$
        </div>
        <div class="formula-card-desc">
          Representa a fração <code>a</code> da população com vida curta (falhas precoces). Parâmetros: escala <code>η₁</code> e forma <code>β₁</code>.
        </div>
      </div>

      <div class="formula-card">
        <div class="formula-card-header">Componente Forte — f₂(x)</div>
        <div class="formula-card-body">
          $$f_2(x) = \frac{\beta_2}{\eta_2}\left(\frac{x}{\eta_2}\right)^{\beta_2-1} \exp\!\left[-\left(\frac{x}{\eta_2}\right)^{\beta_2}\right]$$
        </div>
        <div class="formula-card-desc">
          Representa a fração <code>1 - a</code> da população com vida mais longa. Parâmetros: escala <code>η₂</code> e forma <code>β₂</code>.
        </div>
      </div>

      <div class="formula-card">
        <div class="formula-card-header">Densidade da Mistura — f(x)</div>
        <div class="formula-card-body">
          $$f(x) = a \cdot f_1(x) + (1 - a) \cdot f_2(x)$$
        </div>
        <div class="formula-card-desc">
          Combinação ponderada das duas Weibull. O parâmetro <code>a</code> controla a proporção de componentes fracos na população.
        </div>
      </div>

      <div class="formula-card">
        <div class="formula-card-header">Confiabilidade da Mistura — R(x)</div>
        <div class="formula-card-body">
          $$R(x) = \int_{x}^{\infty} f(t)\, dt = 1 - F(x)$$
        </div>
        <div class="formula-card-desc">
          Probabilidade de o defeito por degradação ainda não ter chegado até o instante <code>x</code>. Calculada numericamente.
        </div>
      </div>

    </div>
  </div>
</div>

<!-- ── MODAL: DELAY-TIME E CHOQUES ── -->
<div class="modal-overlay" id="modal-exp" onclick="closeModalOut(event, 'modal-exp')">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-header-left">
        <div class="modal-icon">E</div>
        <div>
          <div class="modal-title">Delay-time e Choques</div>
          <div class="modal-subtitle">DISTRIBUIÇÕES EXPONENCIAIS</div>
        </div>
      </div>
      <button class="modal-close" onclick="closeModal('modal-exp')">✕</button>
    </div>
    <div class="modal-body">

      <div class="formula-card">
        <div class="formula-card-header">Density do Delay-time — f(h)</div>
        <div class="formula-card-body">
          $$f_h(h) = \lambda\, e^{-\lambda h}, \quad h \geq 0$$
        </div>
        <div class="formula-card-desc">
          O delay-time <code>h</code> é o tempo entre o surgimento do defeito e a falha efetiva. Taxa <code>λ</code>: quanto maior, menor o período de latência médio <code>1/λ</code>.
        </div>
      </div>

      <div class="formula-card">
        <div class="formula-card-header">Acumulada do Delay-time — F(h)</div>
        <div class="formula-card-body">
          $$F_h(h) = 1 - e^{-\lambda h}$$
        </div>
        <div class="formula-card-desc">
          Probabilidade de a falha ocorrer antes de <code>h</code> unidades de tempo após o surgimento do defeito. Usada nos cenários de falha corretiva.
        </div>
      </div>

      <div class="formula-card">
        <div class="formula-card-header">Density dos Choques — f(z)</div>
        <div class="formula-card-body">
          $$f_z(z) = \mu\, e^{-\mu z}, \quad z \geq 0$$
        </div>
        <div class="formula-card-desc">
          O choque externo ocorre no instante <code>z</code>. Taxa <code>μ</code>: quanto maior, mais frequentes os choques. A propriedade de falta de memória implica chegadas aleatórias independentes.
        </div>
      </div>

      <div class="formula-card">
        <div class="formula-card-header">Confiabilidade dos Choques — R(z)</div>
        <div class="formula-card-body">
          $$R_z(z) = e^{-\mu z}$$
        </div>
        <div class="formula-card-desc">
          Probabilidade de nenhum choque ter ocorrido até o instante <code>z</code>. Garante a exclusividade mútua entre os cenários de degradação e de choque.
        </div>
      </div>

    </div>
  </div>
</div>

<!-- ── MODAL: FUNÇÕES DE CUSTO ── -->
<div class="modal-overlay" id="modal-custos" onclick="closeModalOut(event, 'modal-custos')">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-header-left">
        <div class="modal-icon">C</div>
        <div>
          <div class="modal-title">Funções de Custo</div>
          <div class="modal-subtitle">9 CENÁRIOS</div>
        </div>
      </div>
      <button class="modal-close" onclick="closeModal('modal-custos')">✕</button>
    </div>
    <div class="modal-body">

      <div class="formula-card">
        <div class="formula-card-header">Cenários 1 e 5 — Falha antes da inspeção i (corretiva)</div>
        <div class="formula-card-body">
          $$C_1(h) = C_F + C_I(i-1) + C_N \cdot h \qquad C_5(h) = C_F + C_I(i-1) + C_C \cdot h$$
        </div>
        <div class="formula-card-desc">
          Custo corretivo + <code>(i-1)</code> inspeções já realizadas + custo proporcional ao delay-time <code>h</code>. Diferença: <code>C_N</code> para degradação, <code>C_C</code> para choque.
        </div>
      </div>

      <div class="formula-card">
        <div class="formula-card-header">Cenários 2 e 6 — Detectado na inspeção i (preventiva)</div>
        <div class="formula-card-body">
          $$C_2(x) = C_P + C_I \cdot i + C_N(i\Delta - x) \qquad C_6(z) = C_P + C_I \cdot i + C_C(i\Delta - z)$$
        </div>
        <div class="formula-card-desc">
          Custo preventivo + <code>i</code> inspeções + custo proporcional ao tempo de defeito latente <code>(i\Delta - x)</code> ou <code>(i\Delta - z)</code> sem ser detectado.
        </div>
      </div>

      <div class="formula-card">
        <div class="formula-card-header">Cenários 3 e 7 — Falha entre K·D e T (corretiva)</div>
        <div class="formula-card-body">
          $$C_3(h) = C_F + C_I \cdot K + C_N \cdot h \qquad C_7(h) = C_F + C_I \cdot K + C_C \cdot h$$
        </div>
        <div class="formula-card-desc">
          Falha ocorre no período final após as <code>K</code> inspeções, antes de atingir a idade <code>T</code>.
        </div>
      </div>

      <div class="formula-card">
        <div class="formula-card-header">Cenários 4 e 8 — Sobrevive até T (preventiva por idade)</div>
        <div class="formula-card-body">
          $$C_4(x) = C_P + C_I \cdot K + C_N(T - x) \qquad C_8(z) = C_P + C_I \cdot K + C_C(T - z)$$
        </div>
        <div class="formula-card-desc">
          Defeito presente mas o componente é substituído ao atingir a idade <code>T</code>. Custo proporcional ao tempo latente <code>(T - x)</code> ou <code>(T - z)</code>.
        </div>
      </div>

      <div class="formula-card">
        <div class="formula-card-header">Cenário 9 — Sem defeito até T</div>
        <div class="formula-card-body">
          $$C_9 = C_P + C_I \cdot K$$
        </div>
        <div class="formula-card-desc">
          Nenhum defeito até <code>T</code>. Substituição puramente preventiva por idade. Apenas custo preventivo e <code>K</code> inspeções realizadas.
        </div>
      </div>

    </div>
  </div>
</div>

<!-- ── MODAL: TAXA DE CUSTO ── -->
<div class="modal-overlay" id="modal-taxa" onclick="closeModalOut(event, 'modal-taxa')">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-header-left">
        <div class="modal-icon">R</div>
        <div>
          <div class="modal-title">Taxa de Custo</div>
          <div class="modal-subtitle">RESULTADO — C(K, &Delta;, T)</div>
        </div>
      </div>
      <button class="modal-close" onclick="closeModal('modal-taxa')">✕</button>
    </div>
    <div class="modal-body">

      <div class="formula-card">
        <div class="formula-card-header">Fórmula Central</div>
        <div class="formula-card-body">
          $$C(K,&Delta;,T) = \frac{SC}{SV} = \frac{E[\text{Custo do ciclo}]}{E[\text{Duração do ciclo}]}$$
        </div>
        <div class="formula-card-desc">
          A taxa de custo é a razão entre o custo esperado total do ciclo <code>SC</code> e a vida esperada do ciclo <code>SV</code>. Minimizada sobre os parâmetros <code>K</code>, <code>&Delta;</code> e <code>T</code>.
        </div>
      </div>

      <div class="formula-card">
        <div class="formula-card-header">Custo Esperado — SC</div>
        <div class="formula-card-body">
          $$SC = \sum_{j=1}^{9} E[c_j \cdot \mathbf{1}_{\text{cenário }j}]$$
        </div>
        <div class="formula-card-desc">
          Soma ponderada dos custos de cada cenário pela sua probabilidade de ocorrência. Inclui custos corretivos <code>C_F</code>, preventivos <code>C_P</code>, inspeções <code>C_I</code> e custos de latência <code>C_N</code>, <code>C_C</code>.
        </div>
      </div>

      <div class="formula-card">
        <div class="formula-card-header">Vida Esperada — SV</div>
        <div class="formula-card-body">
          $$SV = \sum_{j=1}^{9} E[v_j \cdot \mathbf{1}_{\text{cenário }j}]$$
        </div>
        <div class="formula-card-desc">
          Duração esperada do ciclo ponderada pela probabilidade de cada cenário. Para cenários com falha: <code>v = x + h</code> ou <code>v = z + h</code>. Para preventivos: <code>v = i·&Delta;</code> ou <code>v = T</code>.
        </div>
      </div>

      <div class="formula-card">
        <div class="formula-card-header">Restrição e K ótimo</div>
        <div class="formula-card-body">
          $$K \in \{0, 1, \ldots, K_{\max}\}, \quad K_{\max} = \left\lfloor \frac{T}{&Delta;} \right\rfloor$$
        </div>
        <div class="formula-card-desc">
          O K ótimo é aquele que minimiza <code>C(K, &Delta;, T)</code>. O código itera todos os valores válidos e seleciona o de menor taxa.
        </div>
      </div>

    </div>
  </div>
</div>
<div class="modal-overlay" id="modal-politica" onclick="closeModalOut(event, 'modal-politica')">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-header-left">
        <div class="modal-icon">P</div>
        <div>
          <div class="modal-title">Política de Manutenção</div>
          <div class="modal-subtitle">TAXA DE CUSTO — FÓRMULA COMPLETA</div>
        </div>
      </div>
      <button class="modal-close" onclick="closeModal('modal-politica')">✕</button>
    </div>
    <div class="modal-body">

      <div class="formula-card">
        <div class="formula-card-header">Taxa de Custo</div>
        <div class="formula-card-body">
          $$C(K,&Delta;,T) = \frac{E[\text{Custo do ciclo}]}{E[\text{Duração do ciclo}]} = \frac{SC}{SV}$$
        </div>
        <div class="formula-card-desc">
          Razão entre o custo esperado total e a vida esperada do ciclo. Minimizada sobre <code>K</code>, <code>&Delta;</code> e <code>T</code>.
        </div>
      </div>

      <div class="formula-card">
        <div class="formula-card-header">Restrição da Política</div>
        <div class="formula-card-body">
          $$K \cdot &Delta; \leq T \qquad K_{\max} = \left\lfloor \frac{T}{&Delta;} \right\rfloor$$
        </div>
        <div class="formula-card-desc">
          As <code>K</code> inspeções periódicas devem ocorrer antes da substituição preventiva em <code>T</code>. O número máximo de inspeções é o piso de <code>T/&Delta;</code>.
        </div>
      </div>

      <div class="formula-card">
        <div class="formula-card-header">Probabilidade de cada Cenário — Verificação</div>
        <div class="formula-card-body">
          $$\sum_{j=1}^{9} P(\text{Cenário } j) = 1$$
        </div>
        <div class="formula-card-desc">
          Os 9 cenários são mutuamente exclusivos e coletivamente exaustivos. A soma das probabilidades deve ser igual a 1 para cada combinação válida de <code>(K, &Delta;, T)</code>.
        </div>
      </div>

    </div>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════════════════════
// KDTS — MODELO DE TAXA DE CUSTO COM DELAY-TIME
// ═══════════════════════════════════════════════════════════════════════════════
// El modelo matemático KDTS para calcular la tasa de costo de una política de
// mantenimiento basada en delay-time, con degradación natural
// (mezcla Weibull) y choques externos (Poisson/Exponencial).
//
// ESTRUTURA:
//   1. Funciones de integración numérica  (integrate, integrate2)
//   2. Función principal del modelo      (computeCost)
//      ├── Distribuciones de probabilidad
//      ├── Tabla memoizada de Rx(t)
//      └── 9 escenarios de falla/renovación
//   3. Funciones de interfaz (UI)
//      ├── getParams()     — lee los inputs del formulario
//      ├── runModel()      — valida, lanza Web Worker y muestra resultado
//      ├── showOutput()    — actualiza el área de resultado en el DOM
//      ├── setRunning()    — alterna estado del botón (calculando / listo)
//      ├── resetForm()     — restaura todos los campos a los valores por defecto
//      ├── scrollTo()      — navegación suave por el sidebar
//      └── showToast()     — muestra notificación temporal en la esquina de la pantalla
//   4. Funciones de modal
//      ├── openModal()     — abre un modal de fórmulas
//      ├── closeModal()    — cierra un modal
//      └── closeModalOut() — cierra al hacer clic fuera del modal
// ═══════════════════════════════════════════════════════════════════════════════


// ─── 1. INTEGRAÇÃO NUMÉRICA ──────────────────────────────────────────────────

/**
 * integrate(f, a, b, n)
 * Integración numérica simple por el método de Simpson 1/3.
 *
 * @param {Function} f  - Función a integrar: f(x) → número
 * @param {number}   a  - Límite inferior del intervalo
 * @param {number}   b  - Límite superior del intervalo
 * @param {number}   n  - Número de subintervalos (por defecto: 400; debe ser par)
 * @returns {number}      Valor aproximado de la integral de f entre a y b
 *
 * Fórmula de Simpson 1/3:
 *   ∫f dx ≈ (h/3) * [f(a) + 4f(x₁) + 2f(x₂) + 4f(x₃) + ... + f(b)]
 * donde h = (b-a)/n y los coeficientes alternan 4, 2, 4, 2, ...
 */
function integrate(f, a, b, n = 400) {
  // Si el intervalo es inválido (a ≥ b), la integral es cero
  if (a >= b) return 0;

  const h = (b - a) / n;          // Tamaño de cada subintervalo
  let s = f(a) + f(b);             // La suma comienza con los extremos (coef. 1)

  // Puntos intermedios: coeficiente 4 para índices impares, 2 para pares
  for (let i = 1; i < n; i++) s += (i % 2 === 0 ? 2 : 4) * f(a + i * h);

  return s * h / 3;                // Aplica el factor final h/3
}

/**
 * integrate2(f, ax, bx, upper, nx, nh)
 * Integración doble numérica: ∫∫ f(h, x) dh dx
 * El límite superior de la integral interna (en h) depende de x: upper(x).
 *
 * @param {Function} f      - Función bivariada: f(h, x) → número
 * @param {number}   ax     - Límite inferior de x
 * @param {number}   bx     - Límite superior de x
 * @param {Function} upper  - Límite superior de h en función de x: upper(x) → número
 * @param {number}   nx     - Puntos para la integral externa en x (por defecto: 100)
 * @param {number}   nh     - Puntos para la integral interna en h (por defecto: 100)
 * @returns {number}          Valor aproximado de la integral doble
 *
 * Estrategia: para cada punto x, calcula la integral interna en h usando Simpson,
 * luego acumula los resultados en la integral externa (también Simpson).
 */
function integrate2(f, ax, bx, upper, nx = 100, nh = 100) {
  if (ax >= bx) return 0;          // Intervalo externo inválido → cero

  const hx = (bx - ax) / nx;      // Paso en el eje x
  let sx = 0;

  for (let i = 0; i <= nx; i++) {
    const x  = ax + i * hx;        // Punto actual en x
    const bu = upper(x);            // Límite superior de h para este x
    if (bu <= 0) continue;          // Si el intervalo interno es nulo, omite

    // Integral interna: ∫₀^{upper(x)} f(h, x) dh
    const inner = integrate(h => f(h, x), 0, bu, nh);

    // Coeficiente de Simpson para el eje externo
    const w = (i === 0 || i === nx) ? 1 : (i % 2 === 0 ? 2 : 4);
    sx += w * inner;
  }

  return sx * hx / 3;              // Factor final de la regla de Simpson externa
}


// ─── 2. FUNÇÃO PRINCIPAL DO MODELO ──────────────────────────────────────────

/**
 * computeCost(p, K)
 * Calcula la tasa de costo c(D, T, K) del modelo KDTS.
 * Traducción fiel del modelo analítico Python (función kdts()).
 *
 * La tasa de costo es la razón entre el costo esperado por ciclo y
 * la duración esperada del ciclo (Teorema de Renovación):
 *   c(D, T, K) = E[Costo] / E[Vida] = EC_total / EV_total
 *
 * @param {Object} p  - Objeto con todos los parámetros del modelo:
 *   n1, b1       Escala y forma Weibull — componente débil
 *   n2, b2       Escala y forma Weibull — componente fuerte
 *   a            Proporción de la población débil (mezcla)
 *   l            Tasa exponencial del delay-time (λ)
 *   u            Tasa de llegada de choques externos (μ)
 *   ci           Costo por inspección
 *   cp           Costo de sustitución preventiva
 *   cf           Costo de sustitución correctiva (falla)
 *   cn           Costo unitario de penalización por degradación natural
 *   cc           Costo unitario de penalización por choque
 *   D            Intervalo entre inspecciones
 *   T            Edad de sustitución preventiva
 * @param {number} K  - Número de inspecciones en el ciclo
 * @returns {number}    Tasa de costo c(D, T, K); Infinity si EV_total = 0
 */
function computeCost(p, K) {
  const { n1, b1, n2, b2, a, l, u, ci, cp, cf, cn, cc, D, T } = p;

  // ── 2.1 DISTRIBUCIONES DE PROBABILIDAD ─────────────────────────────────

  // PDF Weibull — componente débil (fracción 'a' de la población, vida corta)
  // f₁(x) = (β₁/η₁) · (x/η₁)^(β₁-1) · exp[-(x/η₁)^β₁]
  const f_debil = x => (b1/n1) * Math.pow(x/n1, b1-1) * Math.exp(-Math.pow(x/n1, b1));

  // PDF Weibull — componente fuerte (fracción '1-a' de la población, vida larga)
  // f₂(x) = (β₂/η₂) · (x/η₂)^(β₂-1) · exp[-(x/η₂)^β₂]
  const f_forte = x => (b2/n2) * Math.pow(x/n2, b2-1) * Math.exp(-Math.pow(x/n2, b2));

  // PDF de mezcla — combina las dos poblaciones con peso 'a' y '1-a'
  // fx(x) = a·f₁(x) + (1-a)·f₂(x)
  const fx = x => a*f_debil(x) + (1-a)*f_forte(x);

  // ── 2.2 TABLA MEMOIZADA DE Rx(t) ──────────────────────────────────────
  // Rx(t) = P(X > t) = ∫ₜ^∞ fx(x) dx  (confiabilidad por degradación natural)
  // Precalcular Rx en una tabla de 2000 puntos uniformes de 0 hasta
  // tMax, usando integración trapezoidal acumulada de atrás hacia adelante.
  // Luego, una interpolación lineal proporciona Rx(t) instantáneamente.

  const tMax  = Math.max(T + 20, 30);  // Límite superior: garantiza capturar toda la distribución
  const RX_N  = 2000;                   // Número de puntos en la tabla
  const RX_dt = tMax / RX_N;            // Espaciado entre puntos

  const RX_table = new Float64Array(RX_N + 1);  // Tabla de valores Rx(i·dt)
  const fxVals   = new Float64Array(RX_N + 1);  // Caché de los valores fx(i·dt)

  // Paso 1: precalcular fx en todos los puntos de la malla
  for (let i = 0; i <= RX_N; i++) fxVals[i] = fx(i * RX_dt);

  // Paso 2: integrar de atrás hacia adelante (de tMax → 0) por el método trapezoidal
  // Rx(t) = Rx(t + dt) + (fx(t) + fx(t+dt)) / 2 · dt
  let acc = 0;
  for (let i = RX_N; i >= 0; i--) RX_table[i] = 0;  // Inicializa tabla con ceros
  for (let i = RX_N - 1; i >= 0; i--) {
    acc += 0.5 * (fxVals[i] + fxVals[i+1]) * RX_dt;
    RX_table[i] = acc;   // Rx(i·dt) = área acumulada de i·dt hasta tMax
  }

  /**
   * Rx(t) — confiabilidad por degradación natural en t
   * Usa interpolación lineal en la tabla precalculada arriba.
   * Complejidad: O(1) por llamada (versus O(n) sin memoización).
   */
  const Rx = t => {
    if (t <= 0)    return RX_table[0];   // Rx(0) = 1 (supervivencia total)
    if (t >= tMax) return 0;             // Más allá de tMax, la PDF ya es ~0

    const idx  = t / RX_dt;             // Posición continua en la tabla
    const i    = Math.floor(idx);        // Índice inferior
    const frac = idx - i;               // Fracción para interpolación

    if (i >= RX_N) return 0;
    // Interpolación lineal entre RX_table[i] y RX_table[i+1]
    return RX_table[i] + frac * (RX_table[i+1] - RX_table[i]);
  };

  // PDF exponencial del tiempo hasta el primer choque externo
  // fz(z) = μ·e^(-μz)
  const fz = z => u * Math.exp(-u*z);

  // Confiabilidad ante choques (probabilidad de ningún choque hasta z)
  // Rz(z) = e^(-μz)
  const Rz = z => Math.exp(-u*z);

  // PDF exponencial del delay-time (duración del período P-F)
  // fh(h) = λ·e^(-λh)
  const fh = h => l * Math.exp(-l*h);

  // Confiabilidad del delay-time (probabilidad de no fallar en h dado defecto)
  // Rh(h) = e^(-λh)
  const Rh = h => Math.exp(-l*h);

  // CDF del delay-time — reservada para extensiones futuras del modelo
  const Fh = h => 1 - Math.exp(-l*h);

  // ── 2.3 ACUMULADORES DE LOS 9 ESCENARIOS ────────────────────────────────
  let P_total  = 0;  // Suma de las probabilidades de todos los escenarios (debe ser ≈ 1)
  let EC_total = 0;  // Esperanza del costo total del ciclo
  let EV_total = 0;  // Esperanza de la duración del ciclo (vida esperada)

  // ═══════════════════════════════════════════════════════════════════════
  // ESCENARIOS 1 y 2 — Degradación natural en las inspecciones periódicas (i = 1..K)
  // ═══════════════════════════════════════════════════════════════════════

  // ESCENARIO 1 — Defecto natural surge en x ∈ [(i-1)D, iD) y falla en x+h < iD
  // El componente falla ANTES de la inspección i → sustitución correctiva (cf)
  // Costo: cf + ci·(i-1) inspecciones realizadas + cn·h penalización por latencia
  // Vida: x + h (instante de la falla)
  for (let i = 1; i <= K; i++) {
    const lo = (i-1)*D, hi = i*D;  // Intervalo de la i-ésima inspección

    // p1: probabilidad de ocurrir este escenario en la inspección i
    const p1  = integrate2((h,x) => Rz(x)*fx(x)*fh(h),                             lo, hi, x => i*D - x);
    // ec1: costo esperado — cf + inspecciones anteriores + penalización natural
    const ec1 = integrate2((h,x) => (cf + ci*(i-1) + cn*h)*Rz(x)*fx(x)*fh(h),      lo, hi, x => i*D - x);
    // ev1: vida esperada — tiempo hasta la falla = x + h
    const ev1 = integrate2((h,x) => (x+h)*Rz(x)*fx(x)*fh(h),                       lo, hi, x => i*D - x);

    P_total  += p1;
    EC_total += ec1;
    EV_total += ev1;
  }

  // ESCENARIO 2 — Defecto natural surge en x ∈ [(i-1)D, iD) pero NO falla hasta iD
  // El defecto ES DETECTADO en la inspección i → sustitución preventiva (cp)
  // Costo: cp + ci·i inspecciones + cn·(iD - x) penalización acumulada hasta detección
  // Vida: iD (instante de la inspección)
  for (let i = 1; i <= K; i++) {
    const lo = (i-1)*D, hi = i*D;

    // p2: probabilidad de que el defecto sobreviva hasta la inspección i
    const p2  = integrate(x => Rz(x)*fx(x)*Rh(i*D - x),                            lo, hi);
    // ec2: costo esperado — cp + todas las i inspecciones + penalización hasta detección
    const ec2 = integrate(x => (cp + ci*i + cn*(i*D - x))*Rz(x)*fx(x)*Rh(i*D - x), lo, hi);
    // ev2: vida esperada — fijada en iD (renovación ocurre en la inspección)
    const ev2 = (i*D) * p2;

    P_total  += p2;
    EC_total += ec2;
    EV_total += ev2;
  }

  // ═══════════════════════════════════════════════════════════════════════
  // ESCENARIOS 3 y 4 — Degradación natural en el intervalo final (K·D, T]
  // ═══════════════════════════════════════════════════════════════════════

  // ESCENARIO 3 — Defecto natural surge en x ∈ (K·D, T] y falla en x+h < T
  // Falla en el intervalo final, tras todas las K inspecciones → sustitución correctiva
  // Costo: cf + ci·K + cn·h
  // Vida: x + h
  {
    const p3  = integrate2((h,x) => Rz(x)*fx(x)*fh(h),                             K*D, T, x => T - x);
    const ec3 = integrate2((h,x) => (cf + ci*K + cn*h)*Rz(x)*fx(x)*fh(h),          K*D, T, x => T - x);
    const ev3 = integrate2((h,x) => (x+h)*Rz(x)*fx(x)*fh(h),                       K*D, T, x => T - x);
    P_total  += p3;
    EC_total += ec3;
    EV_total += ev3;
  }

  // ESCENARIO 4 — Defecto natural surge en x ∈ (K·D, T] pero sobrevive hasta T
  // Defecto detectado en la sustitución preventiva de edad T
  // Costo: cp + ci·K + cn·(T - x) penalización hasta T
  // Vida: T
  {
    const p4  = integrate(x => Rz(x)*fx(x)*Rh(T - x),                              K*D, T);
    const ec4 = integrate(x => (cp + ci*K + cn*(T - x))*Rz(x)*fx(x)*Rh(T - x),     K*D, T);
    const ev4 = T * p4;
    P_total  += p4;
    EC_total += ec4;
    EV_total += ev4;
  }

  // ═══════════════════════════════════════════════════════════════════════
  // ESCENARIOS 5 y 6 — Choque externo en las inspecciones periódicas (i = 1..K)
  // ═══════════════════════════════════════════════════════════════════════

  // ESCENARIO 5 — Choque ocurre en z ∈ [(i-1)D, iD) y falla en z+h < iD
  // Falla por choque ANTES de la inspección → sustitución correctiva
  // Costo: cf + ci·(i-1) + cc·h penalización por latencia del choque
  // Vida: z + h
  for (let i = 1; i <= K; i++) {
    const lo = (i-1)*D, hi = i*D;

    const p5  = integrate2((h,z) => Rx(z)*fz(z)*fh(h),                             lo, hi, z => i*D - z);
    const ec5 = integrate2((h,z) => (cf + ci*(i-1) + cc*h)*Rx(z)*fz(z)*fh(h),      lo, hi, z => i*D - z);
    const ev5 = integrate2((h,z) => (z+h)*Rx(z)*fz(z)*fh(h),                       lo, hi, z => i*D - z);

    P_total  += p5;
    EC_total += ec5;
    EV_total += ev5;
  }

  // ESCENARIO 6 — Choque ocurre en z ∈ [(i-1)D, iD) pero no falla antes de iD
  // Choque detectado en la inspección i → sustitución preventiva
  // Costo: cp + ci·i + cc·(iD - z)
  // Vida: iD
  for (let i = 1; i <= K; i++) {
    const lo = (i-1)*D, hi = i*D;

    const p6  = integrate(z => fz(z)*Rx(z)*Rh(i*D - z),                            lo, hi);
    const ec6 = integrate(z => (cp + ci*i + cc*(i*D - z))*fz(z)*Rx(z)*Rh(i*D - z), lo, hi);
    const ev6 = (i*D) * p6;

    P_total  += p6;
    EC_total += ec6;
    EV_total += ev6;
  }

  // ═══════════════════════════════════════════════════════════════════════
  // ESCENARIOS 7 y 8 — Choque externo en el intervalo final (K·D, T]
  // ═══════════════════════════════════════════════════════════════════════

  // ESCENARIO 7 — Choque en z ∈ (K·D, T] y falla z+h < T
  // Falla por choque en el intervalo final → sustitución correctiva
  // Costo: cf + ci·K + cc·h
  // Vida: z + h
  {
    const p7  = integrate2((h,z) => Rx(z)*fz(z)*fh(h),                             K*D, T, z => T - z);
    const ec7 = integrate2((h,z) => (cf + ci*K + cc*h)*Rx(z)*fz(z)*fh(h),          K*D, T, z => T - z);
    const ev7 = integrate2((h,z) => (z+h)*Rx(z)*fz(z)*fh(h),                       K*D, T, z => T - z);
    P_total  += p7;
    EC_total += ec7;
    EV_total += ev7;
  }

  // ESCENARIO 8 — Choque en z ∈ (K·D, T] pero sobrevive hasta T
  // Choque detectado en la sustitución por edad T → preventiva
  // Costo: cp + ci·K + cc·(T - z)
  // Vida: T
  {
    const p8  = integrate(z => fz(z)*Rx(z)*Rh(T - z),                              K*D, T);
    const ec8 = integrate(z => (cp + ci*K + cc*(T - z))*fz(z)*Rx(z)*Rh(T - z),     K*D, T);
    const ev8 = T * p8;
    P_total  += p8;
    EC_total += ec8;
    EV_total += ev8;
  }

  // ═══════════════════════════════════════════════════════════════════════
  // ESCENARIO 9 — Ningún defecto hasta T: sustitución preventiva exitosa
  // ═══════════════════════════════════════════════════════════════════════
  // El componente llega a T sin defecto natural (Rx(T)) ni choque (Rz(T))
  // Sustitución puramente preventiva por edad
  // Costo: cp + ci·K (todas las K inspecciones se realizaron sin encontrar nada)
  // Vida: T
  {
    const p9  = Rz(T) * Rx(T);           // Prob. de ningún defecto hasta T
    const ec9 = (cp + ci*K) * p9;
    const ev9 = T * p9;
    P_total  += p9;
    EC_total += ec9;
    EV_total += ev9;
  }

  // Tasa de costo final: razón entre costo esperado y vida esperada
  // Si EV_total = 0 (parametrización inválida), retorna Infinity
  return EV_total > 0 ? EC_total / EV_total : Infinity;
}


// ─── 3. FUNÇÕES DE INTERFACE (UI) ────────────────────────────────────────────

/**
 * getParams()
 * Lee todos los valores de los campos de input del formulario HTML y los retorna
 * como un objeto JavaScript con los nombres de los parámetros del modelo.
 * El operador unario '+' convierte el string del input a número.
 *
 * @returns {Object} Objeto con todos los parámetros: n1, b1, n2, b2, a, l, u,
 *                   ci, cp, cf, cn, cc, D, T, K
 */
function getParams() {
  return {
    n1: +document.getElementById('n1').value,  // Escala Weibull débil
    b1: +document.getElementById('b1').value,  // Forma Weibull débil
    n2: +document.getElementById('n2').value,  // Escala Weibull fuerte
    b2: +document.getElementById('b2').value,  // Forma Weibull fuerte
    a:  +document.getElementById('a').value,   // Proporción de la mezcla
    l:  +document.getElementById('l').value,   // Tasa del delay-time (λ)
    u:  +document.getElementById('u').value,   // Tasa de llegada de choques (μ)
    ci: +document.getElementById('ci').value,  // Costo por inspección
    cp: +document.getElementById('cp').value,  // Costo sustitución preventiva
    cf: +document.getElementById('cf').value,  // Costo sustitución correctiva
    cn: +document.getElementById('cn').value,  // Penalización degradación natural
    cc: +document.getElementById('cc').value,  // Penalización choque externo
    D:  +document.getElementById('D').value,   // Intervalo entre inspecciones
    T:  +document.getElementById('T').value,   // Edad de sustitución preventiva
    K:  +document.getElementById('K').value,   // Número de inspecciones en el ciclo
  };
}

/**
 * runModel()
 * Función principal disparada por el botón CALCULAR.
 * Flujo:
 *   1. Lee los parámetros con getParams()
 *   2. Valida los valores (K, D, T deben ser válidos y satisfacer K·D ≤ T)
 *   3. Activa el estado "calculando" (spinner en el botón)
 *   4. Inicia animación de la barra de progreso
 *   5. Crea un Web Worker con el código de computeCost serializado
 *      → El Worker corre en thread separado, evitando bloquear el navegador
 *   6. Al recibir el resultado del Worker, muestra los cards y la tabla de resultado
 *   7. En caso de error, muestra mensaje de error
 */
function runModel() {
  const p = getParams();
  const { K, D, T } = p;

  // Validación básica de los parámetros de decisión
  if (isNaN(K) || isNaN(D) || isNaN(T) || D <= 0 || T <= 0 || K < 0) {
    showOutput(`<div class="error-box">⚠ Parâmetros inválidos. Verifique K, D e T.</div>`);
    return;
  }
  // Restricción estructural del modelo: todas las K inspecciones deben caber antes de T
  if (K * D > T + 1e-9) {
    showOutput(`<div class="error-box">⚠ Restrição violada: K·D = ${(K*D).toFixed(4)} > T = ${T}. Reduza K ou aumente T.</div>`);
    return;
  }

  setRunning(true);   // Desactiva el botón y muestra spinner

  // Muestra la barra de progreso inicial
  showOutput(`<div class="progress-wrap"><div class="progress-top"><span>Calculando c(D=${D}, T=${T}, K=${K})...</span><span id="progPct">—</span></div><div class="progress-track"><div class="progress-fill" id="progFill" style="width:0%;"></div></div></div>`);

  // Animación de la barra: avanza 2% cada 80ms hasta 90% (el resto completa al terminar)
  let pct = 0;
  const animInterval = setInterval(() => {
    pct = Math.min(pct + 2, 90);
    const fill = document.getElementById('progFill');
    if (fill) fill.style.width = pct + '%';
  }, 80);

  // Serializa las funciones necesarias en un string para el Web Worker
  // El Worker no tiene acceso al ámbito principal, por eso las funciones
  // se convierten a string con .toString() y se inyectan en el código del Worker
  const workerCode = `
    ${integrate.toString()}
    ${integrate2.toString()}
    ${computeCost.toString()}
    self.onmessage = function(e) {
      const result = computeCost(e.data.p, e.data.K);
      self.postMessage(result);   // Envía el resultado de vuelta al thread principal
    };
  `;

  // Crea un Blob (archivo virtual) con el código del Worker y genera una URL temporal
  const blob      = new Blob([workerCode], { type: 'application/javascript' });
  const workerUrl = URL.createObjectURL(blob);
  const worker    = new Worker(workerUrl);  // Inicia el Worker en thread separado

  // Callback ejecutado cuando el Worker termina y envía el resultado
  worker.onmessage = function(e) {
    clearInterval(animInterval);       // Detiene la animación de la barra
    URL.revokeObjectURL(workerUrl);    // Libera la URL temporal de la memoria
    worker.terminate();                // Cierra el Worker

    const c = e.data;                  // Resultado: tasa de costo c(D, T, K)

    // Completa la barra de progreso visualmente
    const fill = document.getElementById('progFill');
    if (fill) fill.style.width = '100%';

    // Pequeño delay para que la barra llegue a 100% antes de reemplazar por el resultado
    setTimeout(() => {
      setRunning(false);   // Reactiva el botón

      // Renderiza los cards de resultado y la tabla con los valores calculados
      showOutput(`
        <div class="results-wrap">
          <div class="summary-cards">
            <div class="card">
              <div class="card-label">Variáveis de decisão</div>
              <div class="card-value" style="font-size:16px; letter-spacing:1px;">K=${K} · D=${D} · T=${T}</div>
              <div class="card-sub">${K} inspeção(ões) · intervalo ${D} · idade ${T}</div>
            </div>
            <div class="card">
              <div class="card-label">Taxa de custo</div>
              <div class="card-value">${c.toFixed(6)}</div>
              <div class="card-sub">custo / unidade de tempo</div>
            </div>
          </div>
          <table class="results-table">
            <thead><tr><th>K</th><th>D</th><th>T</th><th>Taxa de custo &nbsp; c(D, T, K)</th></tr></thead>
            <tbody><tr class="best">
              <td class="k-col">${K}</td>
              <td class="k-col">${D}</td>
              <td class="k-col">${T}</td>
              <td class="c-col">${c.toFixed(6)}<span class="best-badge">CALCULADO</span></td>
            </tr></tbody>
          </table>
          <div class="formula-box">
            <div class="formula-title">Parâmetros utilizados</div>
            K = ${K} &nbsp;·&nbsp; D = ${D} &nbsp;·&nbsp; T = ${T}<br>
            cᶠ = ${p.cf} &nbsp;·&nbsp; cₚ = ${p.cp} &nbsp;·&nbsp; cᵢ = ${p.ci} &nbsp;·&nbsp; cₙ = ${p.cn} &nbsp;·&nbsp; cᶜ = ${p.cc}
          </div>
        </div>`);

      showToast(`✓ c(${K}, ${D}, ${T}) = ${c.toFixed(6)}`);
    }, 200);
  };

  // Callback de error del Worker: limpia recursos y muestra mensaje
  worker.onerror = function(err) {
    clearInterval(animInterval);
    URL.revokeObjectURL(workerUrl);
    worker.terminate();
    setRunning(false);
    showOutput(`<div class="error-box">⚠ Erro no cálculo: ${err.message}</div>`);
  };

  // Envía los parámetros al Worker para iniciar el cálculo
  worker.postMessage({ p, K });
}

/**
 * showOutput(html)
 * Reemplaza el contenido del área de resultado (#outputArea) por el HTML proporcionado.
 * Usada para mostrar la barra de progreso, los resultados o mensajes de error.
 *
 * @param {string} html - String HTML a insertar en el DOM
 */
function showOutput(html) {
  document.getElementById('outputArea').innerHTML = html;
}

/**
 * setRunning(on)
 * Alterna el estado visual del botón CALCULAR entre "listo" y "calculando".
 * Cuando on=true: desactiva el botón, reemplaza el ícono por un spinner animado
 *                 y cambia el texto a "CALCULANDO...".
 * Cuando on=false: reactiva el botón, restaura el ícono ▶ y el texto original.
 *
 * @param {boolean} on - true = modo calculando; false = modo listo
 */
function setRunning(on) {
  const btn  = document.getElementById('btnRun');
  const icon = document.getElementById('btnIcon');
  const text = document.getElementById('btnText');
  btn.disabled = on;
  if (on) {
    // Intercambia el ícono ▶ por un spinner CSS animado
    icon.outerHTML = '<span class="spinner" id="btnIcon"></span>';
    text.textContent = 'CALCULANDO...';
  } else {
    // Restaura el ícono original
    const el = document.getElementById('btnIcon');
    if (el) el.outerHTML = '<span id="btnIcon">▶</span>';
    text.textContent = 'CALCULAR TAXA DE CUSTO';
  }
}

/**
 * resetForm()
 * Restaura todos los campos del formulario a los valores por defecto del modelo
 * (equivalentes a los valores del archivo Python original) y limpia el área
 * de resultado mostrando el placeholder inicial.
 */
function resetForm() {
  document.getElementById('n1').value = '0.3';    // Escala Weibull débil
  document.getElementById('b1').value = '3';      // Forma Weibull débil
  document.getElementById('n2').value = '3';      // Escala Weibull fuerte
  document.getElementById('b2').value = '3';      // Forma Weibull fuerte
  document.getElementById('a').value  = '0.05';   // 5% de la población es débil
  document.getElementById('l').value  = '1';      // Tasa delay-time λ = 1
  document.getElementById('u').value  = '0.5';    // Tasa de choques μ = 0.5
  document.getElementById('ci').value = '0.1';    // Costo por inspección
  document.getElementById('cp').value = '1';      // Costo preventivo
  document.getElementById('cf').value = '5';      // Costo correctivo
  document.getElementById('cn').value = '0.04';   // Penalización degradación
  document.getElementById('cc').value = '0.04';   // Penalización choque
  document.getElementById('D').value  = '0.9092'; // Intervalo entre inspecciones
  document.getElementById('T').value  = '8';      // Edad de sustitución
  document.getElementById('K').value  = '5';      // Número de inspecciones

  // Restaura el placeholder gráfico en el área de resultado
  showOutput(`<div class="placeholder">
    <svg width="48" height="48" viewBox="0 0 48 48" fill="none">
      <rect x="8" y="8" width="32" height="32" rx="3" stroke="#5a6070" stroke-width="1.5"/>
      <line x1="16" y1="20" x2="32" y2="20" stroke="#5a6070" stroke-width="1.5"/>
      <line x1="16" y1="26" x2="28" y2="26" stroke="#5a6070" stroke-width="1.5"/>
      <line x1="16" y1="32" x2="24" y2="32" stroke="#5a6070" stroke-width="1.5"/>
    </svg>
    <p>Configure los parámetros arriba<br>y haga clic en CALCULAR</p>
  </div>`);
}

/**
 * scrollTo(id)
 * Navega suavemente hasta la sección con el id proporcionado y marca el ítem del
 * sidebar como activo (resalte visual con borde izquierdo).
 *
 * @param {string} id - ID del elemento HTML de destino (ej: 'sec-weibull')
 */
function scrollTo(id) {
  // Elimina la clase 'active' de todos los ítems del sidebar
  document.querySelectorAll('.sidebar-item').forEach(e => e.classList.remove('active'));
  // Marca el ítem clicado como activo
  event.currentTarget.classList.add('active');
  // Desplaza la página suavemente hasta la sección
  const el = document.getElementById(id);
  if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

/**
 * showToast(msg)
 * Muestra una notificación temporal (toast) en la esquina inferior derecha de la pantalla
 * con el mensaje proporcionado. Desaparece automáticamente tras 3 segundos.
 *
 * @param {string} msg - Texto a mostrar en la notificación
 */
function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');                              // Lo hace visible (CSS transition)
  setTimeout(() => t.classList.remove('show'), 3000);  // Elimina tras 3s
}


// ─── 4. FUNÇÕES DE MODAL ──────────────────────────────────────────────────────

/**
 * openModal(id)
 * Abre el modal de fórmulas con el id proporcionado:
 *   - Añade la clase 'open' al overlay (lo hace visible vía CSS)
 *   - Bloquea el scroll del body mientras el modal está abierto
 *   - Solicita a MathJax que renderice las fórmulas LaTeX dentro del modal
 *
 * @param {string} id - ID del elemento .modal-overlay (ej: 'modal-weibull')
 */
function openModal(id) {
  const overlay = document.getElementById(id);
  overlay.classList.add('open');
  document.body.style.overflow = 'hidden';   // Impide scroll de la página de fondo
  // MathJax renderiza las fórmulas LaTeX ($$...$$) dentro del modal recién abierto
  if (window.MathJax) {
    MathJax.typesetPromise([overlay]).catch(err => console.log(err));
  }
}

/**
 * closeModal(id)
 * Cierra el modal eliminando la clase 'open' y restaurando el scroll del body.
 *
 * @param {string} id - ID del elemento .modal-overlay a cerrar
 */
function closeModal(id) {
  document.getElementById(id).classList.remove('open');
  document.body.style.overflow = '';   // Restaura scroll de la página
}

/**
 * closeModalOut(event, id)
 * Cierra el modal solo si el clic ocurrió en el overlay (fondo oscuro),
 * y no dentro del contenido del modal. Permite cerrar haciendo clic fuera.
 *
 * @param {Event}  event - Evento de clic
 * @param {string} id    - ID del overlay
 */
function closeModalOut(event, id) {
  // Solo cierra si el objetivo del clic es el propio overlay (no un hijo suyo)
  if (event.target === document.getElementById(id)) closeModal(id);
}

// Listener global: cierra cualquier modal abierto al presionar la tecla ESC
document.addEventListener('keydown', e => {
  if (e.key === 'Escape') {
    document.querySelectorAll('.modal-overlay.open').forEach(m => {
      m.classList.remove('open');
      document.body.style.overflow = '';
    });
  }
});
</script>
</body>
</html>
